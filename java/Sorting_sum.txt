Sorting Algorithms
# of Comparisons
# of Swaps/Copies

Bubble Sort O(N^2)
//Swap with left neighbor only if element is less/greater than current element

Selection sort O(N^2)
//Select the minimum/maximum value of rest of elements and swap with it.

Insertion Sort O(N^2)
//find the right inserting position in left sorted part and insert current element there

		    Bubble Sort 	Selection Sort 		Insertion Sort
Best Case	O(n)			O(n^2)				O(n)
Average Case O(n^2)			O(n^2)				O(n^2)
Worst Case   O(n^2)			O(n^2)				O(n^2)
Memory		O(1)			O(1)				O(1)

Insertion Sort best
//但也只适用于范围比较小的数据

int[] a, int left int right;

for (int i = left, j=i;i <right;j=++i){
	int ai =a[i+1];
	while(ai <a[j]){
		a[j+1] =a[j];
		if(j-- == left){
			break;
		}
		a[j+1]=ai;
	}
}

Quick Sort
//pick a pivot
//Put all elements which are less than pivot as left sub-problem
//Put other which are greater than pivot value as right sub-problem.
//Put sub-problem results together when they are solved using same way.
for (int k = less; k<=great;++k){
	if(a[k]==pivot){
		continue;
	}
	int ak=a[k];
	if(ak <pivot){
	// Move a[k] to left part
		a[k]= a[less];
		a[less]= ak;
		++less;
	}else{
	// a[k] > pivot - Move a[k] to right part
	}
}
sort(a, left, less - 1, leftmost);
sort(a, great + 1, right, false);
while (a[great] > pivot) {
	--great;
}
if (a[great] < pivot) { // a[great] <= pivot
	a[k] = a[less];
	a[less] = a[great];
	++less;
} else { 
	// a[great] == pivot
	a[k] = pivot;
}
a[great] = ak;
--great;


Merge Sort
● Cut one array into two parts in the middle.
● If there are just one/two elements within that range, sort them in naive
way. Otherwise, cut them into two.
● Merge sorted sub-problems into one recursively.

int mid = (low + high) >>> 1; low + (high - low) /2
mergeSort(dest, src, low, mid, -off);
mergeSort(dest, src, mid, high, -off);
// If list is already sorted, just copy from src to dest. This is an
// optimization that results in faster sorts for nearly ordered lists.
if (((Comparable)src[mid-1]).compareTo(src[mid]) <= 0) {
	System.arraycopy(src, low, dest, destLow, length);
	return;
}
// Merge sorted halves (now in src) into dest
for(int i = destLow, p = low, q = mid; i < destHigh; i++) {
	if (q >= high || p < mid && ((Comparable)src[p]).compareTo(src[q])<=0)
		dest[i] = src[p++];
	else
		dest[i] = src[q++];


(low + high) >>> 1
● Merge Sort
● Binary Search
● Priority Queue